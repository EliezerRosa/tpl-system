<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TPL - Sistema Automatizado</title>
  <style>
    body { font-family: sans-serif; margin: 20px; background-color: #f5f5f5; }
    h1, h2 { text-align: center; margin-bottom: 5px; }
    h1 { color: white; background-color: #c00000; padding: 10px; border-radius: 8px; }
    h2 { color: white; background-color: #ff8c00; padding: 8px; font-size: 1.1em; margin-bottom: 20px; border-radius: 6px; }
    #sync-controls { display: flex; justify-content: center; align-items: center; gap: 20px; padding: 15px; background-color: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; margin-bottom: 20px; }
    #syncStatus { font-weight: bold; color: #1565c0; }
    #user-status { text-align: center; margin-bottom: 15px; font-size: 0.9em; background: white; padding: 15px; border-radius: 6px; }
    .user-id { color: #666; font-family: monospace; font-size: 0.8em; }
    .user-name { color: #2c5aa0; font-weight: bold; font-size: 1.2em; margin: 5px 0; }
    .name-setup { background: #e3f2fd; border: 2px dashed #2196f3; padding: 20px; margin: 15px 0; border-radius: 8px; text-align: center; }
    .name-setup input { padding: 10px 15px; border: 1px solid #ddd; border-radius: 4px; font-size: 1em; margin: 10px; width: 300px; }
    .name-setup button { padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; }
    .name-setup button:hover { background-color: #45a049; }
    .auth-button { padding: 10px 20px; background-color: #333; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; margin-top: 10px; }
    .auth-button:hover { background-color: #555; }
    table { width: 100%; border-collapse: collapse; border: 2px solid black; background: white; border-radius: 8px; }
    th, td { border: 1px solid #a0a0a0; padding: 8px; text-align: left; vertical-align: top; }
    thead th { background-color: #fff2cc; font-weight: bold; text-align: center; border-bottom: 2px solid black; position: sticky; top: 0; }
    .date-cell, .day-of-week { background-color: #f2f2f2; font-weight: bold; text-align: center; }
    .slot { display: block; min-height: 20px; border-bottom: 1px solid #ccc; margin-bottom: 2px; font-size: 0.9em; padding: 4px; cursor: pointer; border-radius: 4px; }
    .slot.available { background-color: #e8f5e8; border: 1px dashed #4caf50; }
    .slot.my-slot { background-color: #fff3e0; border: 1px solid #ff9800; color: #e65100; font-weight: 500; }
    .slot.taken { background-color: #e3f2fd; border: 1px solid #2196f3; color: #1565c0; cursor: not-allowed; }
    .past-date { opacity: 0.6; background-color: #eeeeee; }
    .past-slot { background-color: #eeeeee !important; color: #b0b0b0 !important; text-decoration: line-through; }
    .log-panel { position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.8); color: #0f0; padding: 10px; border-radius: 8px; font-family: monospace; font-size: 10px; max-width: 350px; max-height: 150px; overflow-y: auto; opacity: 0; transition: opacity 0.5s; pointer-events: none; }
  </style>
</head>
<body>
  <h1>TPL - Sistema Automatizado</h1>
  <h2 id="monthTitle">Programação Semanal Permanente</h2>

  <div id="sync-controls">
    <div id="syncStatus">⚡ Conectando...</div>
    <!-- Botão de login: Adicionado ID, removido onclick -->
    <button class="auth-button" id="adminAuthButton">Login com GitHub</button>
  </div>

  <div id="user-status">
    <div class="user-name" id="userName">Configurar Nome</div>
    <div class="user-id">ID: <span id="deviceId"></span></div>
  </div>

  <div id="nameSetup" class="name-setup" style="display:none;">
    <p><strong>Para participar, configure seu nome:</strong></p>
    <input type="text" id="nameInput" placeholder="Digite seu nome" maxlength="30">
    <!-- Botão de salvar nome: Adicionado ID, removido onclick -->
    <button id="saveNameButton">Salvar Nome</button>
  </div>

  <table id="scheduleTable">
    <thead>
      <tr>
        <th>DIA</th>
        <th></th>
        <th>Manhã<br>7:00</th>
        <th>Manhã<br>9:00</th>
        <th>Tarde<br>14:00</th>
        <th>Tardinha<br>16:00</th>
        <th>Noite<br>18:00</th>
        <th>Observações</th>
      </tr>
    </thead>
    <tbody id="scheduleBody"></tbody>
  </table>

  <div class="log-panel" id="logPanel"></div>

  <script>
    const GITHUB_USER = 'EliezerRosa';
    const GITHUB_REPO = 'tpl-sistema';
    const DAY_NAMES = ['DOM','SEG','TER','QUA','QUI','SEX','SÁB'];
    const MONTH_NAMES = ['Janeiro','Fevereiro','Março','Abril','Maio','Junho','Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'];
    const TIME_SLOTS = [
      { label: '7:00',  hour: 7  },
      { label: '9:00',  hour: 9  },
      { label: '14:00', hour: 14 },
      { label: '16:00', hour: 16 },
      { label: '18:00', hour: 18 }
    ];
    const DAYS_AHEAD = 32;

    // Declarada, mas não inicializada aqui
    let tplSystem = null;

    class TPLSystem {
      constructor() {
        this.deviceId = null;
        this.userName = null;
        this.transactions = new Map();
        this.scheduleState = new Map();
        this.dbUrl = `https://${GITHUB_USER}.github.io/${GITHUB_REPO}/database.json`;
        this.dispatchUrl = `https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/dispatches`;
      }

      async init() {
        this.initIdentity();
        this.restoreTransactions();
        this.renderInitialTable();
        this.setupUI();
        await this.startAutoSync();
        this.handleAuthRedirect();
      }

      initIdentity() {
        let id = localStorage.getItem('tpl_device_id');
        if (!id) {
          id = 'id-' + Math.random().toString(36).substring(2,10);
          localStorage.setItem('tpl_device_id', id);
        }
        this.deviceId = id;
        this.userName = localStorage.getItem('tpl_user_name');
        document.getElementById('deviceId').textContent = id.substring(0, 8);
      }

      restoreTransactions() {
        try {
          const saved = JSON.parse(localStorage.getItem('tpl_transactions') || '[]');
          saved.forEach(tx => this.transactions.set(tx.id, tx));
          this.rebuildSchedule();
        } catch {}
      }

      setupUI() {
        const nameSetup = document.getElementById('nameSetup');
        const userNameEl = document.getElementById('userName');
        if (this.userName) {
          userNameEl.textContent = this.userName;
          // Esconde o setup de nome se o nome já estiver configurado
          nameSetup.style.display = 'none';
        } else {
          nameSetup.style.display = 'block';
        }
        this.updateHeaderMonth();
      }

      updateHeaderMonth() {
        const today = new Date();
        document.getElementById('monthTitle').textContent =
          `Programação - ${MONTH_NAMES[today.getMonth()]} ${today.getFullYear()}`;
      }

      renderInitialTable() {
        const tbody = document.getElementById('scheduleBody');
        tbody.innerHTML = '';
        const today = new Date();
        const todayISO = today.toISOString().split('T')[0];
        const currentHour = today.getHours();

        for (let offset = 0; offset < DAYS_AHEAD; offset++) {
          const date = new Date(today);
          date.setDate(today.getDate() + offset);
          const isoDate = date.toISOString().split('T')[0];
          const row = document.createElement('tr');
          const dateStr = date.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
          const dayName = DAY_NAMES[date.getDay()];

          const cellsHtml = TIME_SLOTS.map(ts => {
            let inner = '';
            for (let i = 0; i < 3; i++) {
              const pastSlot = (isoDate === todayISO) && ts.hour < currentHour;
              const classes = ['slot'];
              if (pastSlot) classes.push('past-slot');
              inner += `<div class="${classes.join(' ')}" data-slot-id="${isoDate}-${ts.label}-${i}"></div>`;
            }
            return `<td>${inner}</td>`;
          }).join('');

          let obs = '';
          for (let i = 0; i < 3; i++) {
            obs += `<div class="slot" data-slot-id="${isoDate}-obs-${i}"></div>`;
          }

          row.innerHTML = `<td class="date-cell">${dateStr}</td>
            <td class="day-of-week">${dayName}</td>
            ${cellsHtml}
            <td>${obs}</td>`;
          tbody.appendChild(row);

          // Marca a linha como passada se a data for anterior ao dia atual
          if (date < new Date(new Date().setHours(0,0,0,0))) {
            row.classList.add('past-date');
          }
        }

        tbody.querySelectorAll('.slot').forEach(div => {
          // Os event listeners são adicionados apenas para slots que NÃO são "past-slot"
          // Os slots de data passada recebem a classe 'past-date' na linha inteira,
          // mas isso não impede o clique a menos que o slot também seja 'past-slot'
          if (!div.classList.contains('past-slot') && !div.closest('.past-date')) {
             div.addEventListener('click', () => this.handleSlotClick(div));
          }
        });
      }

      handleSlotClick(el) {
        if (!this.userName) {
          alert('Configure seu nome antes de interagir com a agenda.');
          document.getElementById('nameSetup').style.display = 'block';
          return;
        }
        this.toggleSlot(el.dataset.slotId);
      }

      async toggleSlot(slotId) {
        const currentTxId = this.scheduleState.get(slotId);
        const currentTx = currentTxId ? this.transactions.get(currentTxId) : null;
        if (currentTx && currentTx.ownerId === this.deviceId) {
          await this.createTransaction(slotId, 'delete');
        } else if (!currentTx) {
          await this.createTransaction(slotId, 'set');
        }
      }

      async createTransaction(slotId, action) {
        const data = (action === 'set')
          ? { name: this.userName, deviceId: this.deviceId }
          : null;

        const tx = {
          id: 'tx-' + Math.random().toString(36).substring(2),
          timestamp: Date.now(),
          slotId,
          action,
          ownerId: this.deviceId,
          data
        };

        this.transactions.set(tx.id, tx);
        this.rebuildSchedule();
        localStorage.setItem('tpl_transactions', JSON.stringify(Array.from(this.transactions.values())));
        this.refreshSlots();

        // Tenta disparar o evento GitHub (pode falhar sem auth, mas o estado local é atualizado)
        try {
            await fetch(this.dispatchUrl, {
              method: 'POST',
              headers: {
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
                // Para repository_dispatch, você não precisa de token aqui,
                // a action será acionada se o payload for válido.
                // A autenticação é gerenciada pelo GitHub Actions.
              },
              body: JSON.stringify({
                event_type: 'nova-transacao',
                client_payload: { transaction: JSON.stringify(tx) }
              })
            });
            console.log("Transação enviada para o GitHub Actions.");
        } catch (error) {
            console.error("Erro ao enviar transação para GitHub Actions:", error);
            alert("Erro ao sincronizar com o servidor. A transação foi salva localmente e tentará sincronizar mais tarde.");
        }
      }

      rebuildSchedule() {
        this.scheduleState.clear();
        const ordered = Array.from(this.transactions.values()).sort((a, b) => a.timestamp - b.timestamp);
        const map = new Map();
        for (const tx of ordered) {
          if (tx.action === 'set') {
            if (!map.has(tx.slotId)) map.set(tx.slotId, tx.id);
          } else if (tx.action === 'delete') {
            const setId = map.get(tx.slotId);
            if (setId) {
              const ref = this.transactions.get(setId);
              // Apenas permite deletar se o slot foi originalmente criado pelo mesmo deviceId
              if (ref && ref.ownerId === tx.ownerId) {
                map.delete(tx.slotId);
              }
            }
          }
        }
        this.scheduleState = map;
      }

      refreshSlots() {
        document.querySelectorAll('.slot[data-slot-id]').forEach(div => {
          const slotId = div.dataset.slotId;
          const txId = this.scheduleState.get(slotId);
          const tx = txId ? this.transactions.get(txId) : null;
          div.className = 'slot'; // Reset classes
          div.textContent = ''; // Clear content

          // Reaplicar classes de tempo passado para slots
          const [isoDate, timeLabel, index] = slotId.split('-');
          const today = new Date();
          const currentHour = today.getHours();
          const slotHour = TIME_SLOTS.find(ts => ts.label === timeLabel)?.hour;
          const isToday = (new Date(isoDate).toDateString() === today.toDateString());
          const pastSlot = isToday && slotHour !== undefined && slotHour < currentHour;

          if (pastSlot) {
            div.classList.add('past-slot');
            div.removeEventListener('click', () => this.handleSlotClick(div)); // Remove listener para slots passados
          } else if (div.closest('.past-date')) { // Se a linha inteira é de data passada
             div.classList.add('past-slot'); // Trata como slot passado visualmente
             div.removeEventListener('click', () => this.handleSlotClick(div)); // Remove listener
          } else {
             // Re-adiciona o listener se não for passado (garantindo que só há um)
             if (!div.hasAttribute('data-has-listener')) {
                div.addEventListener('click', () => this.handleSlotClick(div));
                div.setAttribute('data-has-listener', 'true');
             }
          }


          if (tx && tx.data) {
            div.textContent = tx.data.name;
            div.classList.add(tx.ownerId === this.deviceId ? 'my-slot' : 'taken');
          } else if (!pastSlot && !div.closest('.past-date')) {
            div.classList.add('available');
          }
        });
      }

      async fetchLatestData() {
        try {
          // Adiciona um cache-buster para garantir que sempre pega a versão mais recente
          const resp = await fetch(`${this.dbUrl}?v=${Date.now()}`);
          if (!resp.ok) throw new Error('Status ' + resp.status);
          const json = await resp.json();
          let added = 0;
          let transactions = [];
          if (Array.isArray(json)) {
            transactions = json;
          } else if (json?.transactions && Array.isArray(json.transactions)) {
            transactions = json.transactions;
          }
          transactions.forEach(t => {
            // Garante que o objeto de transação é válido antes de adicionar
            if (t && typeof t.id === 'string' && !this.transactions.has(t.id)) {
              // Garante que o payload é um objeto JSON válido
              const tx = typeof t === 'string' ? JSON.parse(t) : t;
              this.transactions.set(tx.id, tx);
              added++;
            }
          });
          if (added) {
            console.log(`Sincronizado: ${added} novas transações adicionadas.`);
            this.rebuildSchedule();
            localStorage.setItem('tpl_transactions', JSON.stringify(Array.from(this.transactions.values())));
            this.refreshSlots();
          }
          document.getElementById('syncStatus').textContent = '✅ Sincronizado';
          document.getElementById('syncStatus').style.color = '#4CAF50'; // Verde
        } catch (err) {
          console.error('Erro de sincronização:', err.message);
          document.getElementById('syncStatus').textContent = '⚠️ Erro de Sincronização';
          document.getElementById('syncStatus').style.color = '#f44336'; // Vermelho
        }
      }

      async startAutoSync() {
        await this.fetchLatestData();
        // Aumentando o intervalo para 1 minuto (60000ms) para reduzir requisições desnecessárias
        setInterval(() => this.fetchLatestData(), 60000);
      }
      
      // Nova função para iniciar o fluxo de autenticação OAuth
      async startAdminAuth() {
        const clientId = 'Ov23likR1Y8H4FdShZkb';
        // A redirectUri deve ser a URL exata da sua página onde o usuário será redirecionado
        // após a autorização no GitHub. Pode ser a URL do GitHub Pages.
        const redirectUri = window.location.origin + window.location.pathname;
        window.location.href = `https://github.com/login/oauth/authorize?client_id=${clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&scope=repo,workflow`;
      }

      // Função para lidar com o redirecionamento OAuth e acionar o robô de setup
      async handleAuthRedirect() {
        const urlParams = new URLSearchParams(window.location.search);
        const code = urlParams.get('code');
        if (code) {
          alert('Autenticação iniciada. O robô está trabalhando para salvar o token.');
          try {
            await fetch(this.dispatchUrl, {
              method: 'POST',
              headers: {
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                event_type: 'setup-admin-token',
                client_payload: { code: code }
              })
            });
            console.log("Evento 'setup-admin-token' disparado com sucesso.");
            // Remove o 'code' da URL para limpeza
            window.history.replaceState({}, document.title, window.location.pathname);
          } catch (error) {
            console.error("Erro ao disparar evento 'setup-admin-token':", error);
            alert("Erro ao iniciar o setup do token de administrador.");
            window.history.replaceState({}, document.title, window.location.pathname);
          }
        }
      }
    }

    // Função global setupUser, conforme já existia, mas agora chamada via event listener
    function setupUser() {
      const input = document.getElementById('nameInput');
      const name = input.value.trim();
      if (!name) {
        alert('Informe seu nome.');
        return;
      }
      tplSystem.userName = name;
      localStorage.setItem('tpl_user_name', name);
      tplSystem.setupUI(); // Atualiza a UI e esconde o setup de nome
      tplSystem.refreshSlots();
    }

    // A instância de TPLSystem é criada e inicializada AQUI,
    // após o DOM estar completamente carregado e parseado.
    document.addEventListener('DOMContentLoaded', async () => {
      tplSystem = new TPLSystem(); // Cria a instância
      await tplSystem.init();      // Inicializa a instância
      tplSystem.refreshSlots();    // Atualiza os slots com os dados iniciais

      // Anexa event listeners aos botões
      const adminAuthButton = document.getElementById('adminAuthButton');
      if (adminAuthButton) {
        adminAuthButton.addEventListener('click', () => {
          tplSystem.startAdminAuth();
        });
      }

      const saveNameButton = document.getElementById('saveNameButton');
      if (saveNameButton) {
        saveNameButton.addEventListener('click', setupUser);
      }

      // Atualiza o status de sincronização inicial
      document.getElementById('syncStatus').textContent = '⚡ Conectando...';
    });
  </script>
</body>
</html>